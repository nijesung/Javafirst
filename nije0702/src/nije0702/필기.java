 // "메소드"

// 메인 메소드는 실행의 용도로만 사용한다. *절대로 변수 등을 설정하지 않는다*
// 모든 메소드는 클래스 안에 소속되어야 한다. (호출은 인스턴스가 할 수 있지만)
// 모든 프로그램에서 작업의 단위는 메소드 혹은 함수이다.
// 메소드의 선언
// 접근지정자 + [특성] + 결과형 + 메소드명(매개 변수 나열)=(arg)

// 특성
// abstract - 추상 메소드 선언에 사용 (반드시 오버라이딩 해서 사용)
// final - 종단 메소드 선언에 사용 - 오버라이딩 할 수 없음

// static - 클래스 메소드 선언
// 메소드 결과형 앞에 static 을 추가한 메소드, 클래스 이름으로 호출할 수 있는 메소드
// 인스턴스 변수를 사용할 수 없고 객체 생성 없이 메소드를 사용하기 위해서 생성한다.

// synchronized - 스레드 임계 영역 처리에 사용
// native: c 언어와 같은 native 언어의 메소드를 사용하고자 하는 경우 선언 

// 결과형
// 메소드를 수행 하는 결과로 반환되는 값의 자료형
// void - 반환 값 없음을 의미
// return - 메소드 수행 후 결과를 반환할 때 사용하는 예약어로 이 키워드를 만나면 메소드 영역에서 벗어나게 된다.
//          메소드의 수행이 종료되고 메소드를 호출한 지점으로 돌아오도록 하는 명령어
//          메소드의 수행이 종료된 상태에서 어떤 결과를 호출한 지점으로 넘겨주고자 하면 메소드의 이름 앞에 넘겨주고자 하는
//          데이터의 자료형을 기재하고 return 다음에 결과를 입력해주면 된다.
//          메소드의 return이 없을 때는 자료형 대신에 void라고 입력하고 void 메소드는 메소드를 출력한 이후에 연속해서
//          작업을 호출할 수 없다.

// argument - 매개변수 라고 번역하는데 메소드를 호출할 때 호출하는 쪽에서 넘겨주어야 하는 데이터
//            메소드를 선언할 때 괄호안에 자료형과 변수명을 기재하면 메소드를 호출할 때 데이터를 넘겨주어야 한다.
//            없으면 생략이 가능하고 갯수 제한은 없다.

// *매개 변수 호출방법*
// 매개 변수의 자료형이 value형 인지 reference형 인지로 구분
// Call by value : 매개변수의 자료형이 value형 인 경우 (값을 저장하고 있는 경우)
//                 메소드에서 원본의 데이터를 변경할 수 없다.

// Call by reference : 매개변수의 자료형이 참조형인 경우 (주소를 저장하고 있는 경우)
//                     메소드에서 원본의 데이터를 변경할 수도 있다.

// 재귀호출(recursion - recursive call) : 메소드가 자기 자신을 다시 호출하는 것 (합계, 팩토리얼, 피보나치 수열,하노이의 탑)
//                                      단점: 메모리 사용량도 늘어나고 속도도 느리다. 장점: 코드간결화, 이해가 쉽다

// 피보나치수열 - 첫번쨰와 두번째 항은 1, 세번째 항 부터는 앞 2개 항의 합, 위의 규칙을 만족하는 수열을 피보나치 수열이라고 한다.
//            예): 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 (금융에서 이전 데이터를 가져올 때 가장 많이 쓰임)

// **접근자메소드
// 인스턴스 변수를 private 으로 만들면 인스턴스가 변수에 접근을 못 하게 되는데 이 때 변수를 사용할 수 있도록 만들어주는 메소드를
// 접근자 메소드라고 한다.
// 데이터를 가져오는 메소드를 getter 라고 하고 데이터를 성정하는 메소드를 setter 라고 한다.
// 1) getter
// 접근지정자는 public 으로 하고 리턴 타입은 변수의 자료형과 동일하게 하고 이름은 get 변수명으로 만드는데 변수명의 첫글자는 대문자로
// 시작한다. 매개변수는 없으며 내용은 변수를 리턴하기만 하면 된다.
// 이름은 예외적으로 boolean 인 경우에는 get 대신에 is 를 붙이기도 한다.

// *method overloading(중복 정의) - # 면접보러 갈 때 한번은 보고 가라(중요)(요즘은 잘 쓰지 않는다)
// 하나의 클래스에 메소드의 이름은 같고 매개변수의 자료형이나 개수가 다른 메소드가 존재하는 경우
// 동일한 이름의 메소드가 2개 이상 존재하는 경우, 동일한 역할을 하는 메소드의 이름을 동일하게 만들기 위해서 제공하는 기능인데
// 최근에는 메소드의 이름으로 구별하거나 제너릭으로 대체하는 경우가 많다.

// 예) 정수 2개를 더해서 그 결과를 리턴하는 메소드와 실수 2개를 더해서 그 결과를 리턴하는 메소드를 생성하고자 하는 경우
//    1.오버로딩이 안 된다면.
//     public int addinteger (int a, int b){
//     return a + b;
//     }
//     public double addDouble (double a, double b){
//     return a + b;
//     }
//
//    2.오버로딩이 허용되는 경우
//     public int add (int a, int b){
//     return a + b;
//     }
//     public double add (double a, double b){
//     return a + b;
//     }
//
// *varargs(가변매개변수)
// 매개변수를 개수에 상관없이 대입할 수 있도록 해주는 문법
// 메소드를 선언할 때 매개변수를 자료형 ... 변수명의 형식으로 기재하면 메소드를 호출할 때 자료형의 데이터를 몇 개를 대입해도 상관없다.
// 메소드 내에서는 배열로 처리한다.

// 메소드에서 중요한 것(메소드를 호출할 때 확인해야 할 3가지)
// 1. static 이 붙어있는지 안 붙어있는지 확인
//    스태틱이 없는 메소드를 호출하려면 인스턴스를 생성하고 인스턴스를 가지고 호출해야 한다.
//    static이 붙은 메소드이면 클래스 이름을 가지고 호출하면 된다.
//
// 2. 메소드의 매개변수를 확인해야 한다.
//    메소드를 호출할 때 매개변수를 정확하게 주지 않으면 에러가 발생한다.
//
// 3. 메소드의 리턴 타입을 확인한다.
//    리턴 타입이 void 이면 호출하는 것으로 끝내고, void 가 아니면 변수에 저장을 하던지 다른 연산에 이용을 한다.
//
// <Constructor(생성자)>
// 인스턴스를 생성할 때 호출하는 메소드. 모든 클래스에는 생성자가 반드시 존재
// 생성자를 별도로 만들지 않으면 매개변수가 없는 생성자가 자동으로 생성된다.
// 생성자를 직접 만드는 이유는 인스턴스의 변수를 초기화하거나 인스턴스를 생성할 때 수행해야 할 작업을 작성하기 위해서이다. 
// 생성자의 규칙
// 1. 이름은 반드시 클래스 이름과 동일해야 한다.
// 2. 리턴 타입은 없다. (적으면 안 된다)
// 3. 생성자를 직접 만들면 처음 제공되는 생성자는 소멸된다.
// 4. 생성자도 오버로딩이 가능하다. (여러 개 생성 가능)
// 5. IDE에는 생성자도 자동으로 만들어주는 기능이 존재한다.
// 6. 인스턴스를 만들 때는 반드시 생성자를 호출해야 한다.
// 7. 생성자 호출시 - new 생성자(매개변수)
// 7. 생성자를 호출하면 생성자를 가지고 인스턴스를 만들고 그 인스턴스의 주소를 리턴합니다.

// 생성자를 만드는 이유
// 1. 인스턴스 변수를 초기화 하고자 할 때 - 0이나 false 또는 null 이 아닌 값을 갖도록 하고자 할 때
// 2. 매개변수를 넘겨받아서 초기화(initialize)하고자 할 때
// 3. 매개변수가 없는 생성자 - default constructor 라고 한다.
// 3. 이 생성자가 없는 클래스의 경우 인스턴스를 생성할 때 반드시 매개변수를 넘겨서 생성해 주어야 하고 상속을 하는 경우 하위 클래스에서 반드시
//    상위 클래스의 생성자를 호출해야 한다.
// 4. 매개변수가 있는 생성자
//    외부에서 값을 받아서 인스턴스 변수를 초기화하고자 할 때 이 생성자를 만든다.
//    이렇게 외부에서 데이터를 받아서 초기화하는 것을 dependency injection(의존성 주입) 이라고 한다.
//    생성자를 여러 개 만들면 인스턴스를 생성하는 방법이 다양해지게 된다.
//    인스턴스를 만들 때는 생성자를 참조해서 만들어야 한다.

// 생성자를 이용하지 않는 초기화
// 1. Static Initializer - 클래스가 메모리에 로드될 때 단 1번만 수행. 단 1번만 실행하고 싶을 때. 인스턴스 변수는 사용 불가능.
//    static {              
//    내용:
//    }
// 2. Initializer - 인스턴스를 생성 할 때마다 수행 (new 할 때마다 호출)
//    {                       
//       내용:
//    }

// *this
// 인스턴스 메소드에서 인스턴스 자신의 주소를 저장한 숨겨진 매개변수
// 사용 이유: 인스턴스 메소드에 지역 변수와 인스턴스 변수의 이름이 같을 때 인스턴스 변수를 가리키기 위해서 사용
//         
//
// *package & import*
// package: 관련있는 클래스의 집합. 디렉토리와유사, "jar" 로 압축해서 제공. (사용 중일 때를 의미함)
// library: 프로그램을 만드는 데 도움을 주는 파일의 집합. 
// 1. 기업 제공은 sdk. 2. 기업이 아닌 개인이 제공하는 것이 "서드파티" 3. 개발자가 직접 제작
// framework: 프로그램을 쉽게 개발하게 해주는 도구 (예: 비주얼 스투디오, Spring framework) (범용)
// solution: 특정목적에 맞는 프로그램을 제작 해 주는 도구  (타겟이 있음)

// include: 소스에 포함. 가져오는 개념
// import: java에서의 import는 개념이 다르다. 이름을 줄여쓰기 위해서 사용 (예: Scanner 는 원래 java.util.Scanner)
// 방법 1 : import 패키지이름. 클래스이름 - 패키지에 있는 클래스 중에서 클래스 이름에 해당하는 클래스는 패키지 이름을 생략해도 된다.
// 방법 2 : import 패키지이름. * -  패키지에 있는 모든 클래스들은 패키지 이름을 생략해도 된다.
// java에서는 java.lang 패키지는 기본적으로 import가 되어 있다. (예: String)

// **상속(Inheritance)
// =>상위 클래스의 모든 멤버를 하위 클래스가 물려 받는 것
// 1.하는 이유
// =>중복된 코드를 제거해서 코드를 간결하게 만들고 유지보수를 편리하게 하기 위해서
// =>기존에 제공된 기능에 내용을 추가하고자 해서

// 2.하는 방법
// 클래스 이름 뒤에 extends를 쓰고 상위 클래스 이름을 적어주면 된다.

// 3.private 멤버는 상속은 되는데 하위 클래스에서 접근을 할 수 없다.
// 하위 클래스에서 접근하도록 하기 위해서는 접근 지정자를 protected 나 public으로 변경해야 한다.



package nije0702;

public class 필기 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub b

	}

}
