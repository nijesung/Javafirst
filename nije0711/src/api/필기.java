// ** 자료구조(Date Structure)
// 데이터를 어떤 방법으로 저장할 것 인지

// **Collection
// 데이터의 묶음을 의미하고 대표적인 것이 배열이다.

// Enumerator & lterator
// 둘 다 반복자나 열거자라는 단어로 번역되는데 Java 에서는 Enumerator 가 예전에 나온 반복자이고 lterartor 가 최근에 나온 반복자이다.
// 예전 API 클래스들은 Enumerator 라고 하고 최근에 나온 API 클래스들은 lterartor 라고 합니다.
// 맨 처음 데이터의 시작 이전 지점(BOF)을 가리키고 있다가 next()를 호출하면 다음 데이터를 가리키는 구조를 가진 포인터
// 예):
// - >BOF(Begin Of File)
//     2
//     5
//     7

// **List 인터페이스
// 데이터를 순서대로 나열하는 자료구조의 상위 인터페이스
// 데이터를 순서대로 나열하는 자료구조 들의 공통된 작업을 위한 메소드 이름만을 가지고 있다.
// Array(배열) 도 데이터를 순서대로 나열하는 자료구조 이나 크기 변경은 되지 않는다.
// 배열의 저장된 데이터 값을 변경 할 수는 있지만 배열의 데이터를 삭제하거나 삽입 하려면 배열을 복사해서 작업을 수행해야 한다.
// 배열은 데이터를 반드시 순서대로 연속해서 저장해야만 하기 때문이다. (늘어나는것도 줄이는 것도 불가능하다)
// List 는 배열이 이러한 단점을 보완하기 위해 여분의 공간을 확보하고 있다가 데이터가 추가되면 그 여분의 공간을 활용하는 자료구조이다.
// 1. 공통된 메소드
// 1-1. size(): 데이터 갯수 리턴
// 1-2. void add(데이터): 데이터를 마지막에 추가
// 1-3. 데이터 get(인덱스): 인덱스 번 째의 데이터를 리턴
// 1-4. void remove(데이터): 삭제
// 대부분이 빠른 열거를 사용할 수 있다.

// 2. Vector & ArrayList
// 데이터를 순서대로 연속해서 저장하는 List
// 동작하는 메소드나 저장하는 방식은 동일하나 Vector 는 MultiThread 에 safe 하고 ArrayList 는 Unsafe 하다.
// Vector 는 Legacy Collection 이라 일컫으며 사용을 권장하지 않는다.

// 3. Linked List
// 다음 데이터를 가리키는 리스트
// 한 방향으로 가리키는 것을 Single linked list 라고 하고 양방향으로 가리키는 것을 double linked list 라고 한다.
// Java 에서는 클래스 이름만 LinkedList 이고 사용법은 ArrayList 와 동일하다.

// 4. 배열과 ArrayList(Vector) 그리고 LinkedList
// 배열과 다른 List 보다 공간 낭비가 적다. 배열은 크기 확장이 되지 않기 때문에 여분의 공간을 가지고 있지 않기 때문이다.
// 데이터를 중간에 삽입하거나 삭제하는 작업은 복사 작업과 같이 해야 하기 때문에 속도가 느리다.

// ArrayList 는 연속된 공간에 데이터를 저장하고 여분의 공간을 가지고 데이터를 중간에 삽입하거나 삭제 할 수 있다.
// 대신에 중간에 삽입이나 삭제를 하려면 다른 데이터를 이동시켜야 하기 때문에 시간이 많이 걸린다.

// LinkedList 는 다음 데이터의 주소를 저장해서 다음 데이터를 찾아가는 자료구조이기 때문에 연속된 빈 공간이 없어도 데이터를 저장할 수 있고
// 중간에 데이터를 삽입하거나 삭제할 때 포인터만 변경되기 때문에 빠르게 작업을 수행할 수 있다는 장점을 가지고 있지만 이전 데이터를 확인하지
// 않고 다음 데이터를 조회할 수는 없기 때문에 접근 속도는 매우 느리다.

// # 데이터의 개수가 변경 될 가능성이 없는 경우에는 배열을 사용하고, 삽입과 삭제가 빈번히 발생하는 클라이언트 프로그램의 경우 LinkedList
// 를 많이 사용하며 읽어내는 속도가 중요한 서버 프로그램의 경우에는 ArrayList 를 많이 사용한다.

// 5. List 의 정렬
// sort 메소드를 호출하면 된다.
// 정렬을 하기 위해서는 크기 비교를 할 수 있는 메소드를 소유하고 있거나 크기 비교를 할 수 있는 인스턴스를 만들어 주어야 한다.
// Comparator 인터페이스를 implements 한 클래스의 인스턴스를 대입하면 된다.

// 6. Stack
// LIFO(Last In First Out): 마지막에 삽입된 데이터가 가장 먼저 출력되는 자료 구조
// 변수 선언 할 때 순서대로 저장하는 용도로 사용
// 메소드 호출했을 때 호출한 곳의 주소 등을 저장
// 스마트 폰 애플리케이션 에서 네비게이션 이 스택을 이용한다.
// java.util.Stack 이라는 클래스로 지원
// 데이터를 삽입하는 메소드: push (데이터)
// 데이터를 삭제하고 꺼내는 메소드: pop()
// 데이터를 삭제하지 않고 꺼내는 메소드: peek()
// 직접 만들어서 사용하는 경우보다는 시스템이 사용하는 경우가 많다.

// 7. Queue
// FIFO(First In First Out): 먼저 삽입된 데이터가 먼저 출력되는 자료 구조
// 스케줄링(작업 순서)등 이용
// java 에서는 java.util.Queue 라는 인터페이스를 통해서 제공
// ArrayList 등이 이 인터페이스를 implements 했고 PriorityQueue(우선순위 큐- 데이터를 순서대로 정렬해서 저장)
// 클래스가 Queue 인터페이스를 implements 했다.

// 8. Deque
// 양쪽에서 삽입과 삭제가 가능한 자료 구조
// 스크롤 뷰에 사용
// 면접 보러 갈 때 반드시 숙지
// C 언어로 취업을 하고자 할 때는 LinkedList 는 직접 구현 할 수 있어야 한다.
// 자기 참조 구조체를 이용하여 구현하면 된다.

// **set
// 데이터를 중복 없이 저장하는 자료 구조
// 데이터를 저장할 때 순서와는 상관 없이 해싱이라는 방법을 이용하여 저장
// 데이터를 저장하는 메소드는 있지만 데이터를 가져오는 메소드는 존재하지 않는다.
// 데이터를 가져올 때는 빠른 열거를 이용하여 전체 데이터를 가져와야 한다.
// 삭제하는 메소드와 리턴하는 메소드는 존재
// Set 은 인터페이스 이고 Set 을 구현한 클래스로는 HashSet(저장된 순서를 알 수 없음), LinkedHashSet(저장된 순서를 기억), 
// TreeSet(크기를 기억) 이 있다.
// 데이터를 추가하는 메소드는 add 인데 데이터를 추가하는 데 실패하면 false 를 리턴한다.
// 데이터를 추가하는 데 실패한 경우는 중복된 데이터를 삽입하려고 한 경우이다.
// 직접 사용하는 빈도는 높지 않다.

// **Map
// Key 와 Value 를 쌍으로 저장하는 자료 구조
// Key 는 Set 으로 저장된다.
// Key 는 중복될 수 없다. (Set 으로 저장되니까)
// 데이터를 저장하는 클래스 처럼 데이터를 이름과 함께 저장해서 이름으로 빠르게 찾아서 사용할 목적으로 만들 클래스
// Map 은 인터페이스 이고 Map 을 구현한 클래스로는 HashMap, LinkedHashMap, TreeMap 이 있다.

// 1. HashMap
// 1-1. 생성자
// HashMap<key 의 자료형, value 의 자료형>()
// Key 의 자료형은 특별한 경우가 아니면 String
// Value 의 자료형은 아무런 데이터나 저장할 수 있도록 Object 로 하는 경우가 많다.

// 1-2. 주요 메소드
// Put(키,데이터): 키 이름으로 데이터가 저장되는데 동일한 키 이름이 있으면 수정이 되고 동일한 이름이 없으면 추가된다.

// Object get(키): 키에 해당하는 데이터를 Object 타입으로 리턴
//                 키에 해당하는 데이터가 없으면 null 을 리턴
//                 리턴되는 데이터가 Object 타입이므로 get 해서 사용할 때는 저장할 때의 자료형으로 강제 형 변환하여 사용해야 한다.

// void remove(키): 키에 해당하는 데이터을 삭제

// int siza(): 데이터 갯수 리턴

// Set<키의 자료형> KeySet(): 모든 Key 들을 Set 으로 만들어서 리턴


package api;

public class 필기 {

}
