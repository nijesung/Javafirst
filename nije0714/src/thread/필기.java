// 3. 스레드의 강제 종료
// 스레드 클래스의 run 메소드에 InterrupteException 이 발생하였을 때 return 하는 코드를 추가한다.
// 스레드 인스턴스에서 interrupt() 를 호출하면 된다.

// 4. 멀티 스레드를 사용할 때 고려 사항
// 공유 자원의 문제를 고민해야 한다.
// 공유 자원을 동시에 수정하는 문제나 순차적으로 사용해야 하는 경우들을 고려해야 한다.
// 4-1. critical section(임계 영역)
//      공유 자원을 사용하는 코드 영역
// 4-2. mutual exclusion(상호배제)
//      하나의 스레드가 사용 중인 공유자원은 다른 스레드가 수정하면 안된다.
//      java 에서는 synchronized 메소드를 만들거나 synchronized 블럭을 만들어서 해결한다.
// 4-3. consumer problem(생산자와 소비자 문제)
//      생산자와 소비자는 자원을 공유해서 사용할 수 있지만 소비자는 생산자가 자원을 생성해 준 경우에만 사용할 수 있다.
//      synchronized 메소드와  wait, notify, notifyAll 메소드로 해결

// ex)
// 잔액이라는 변수와 잔액에서 100을 차감하는 메소드를 생성하는 클래스를 생성 - 공유 자원
// 스레드 클래스를 만들어서 앞에서 만든 클래스의 메소드를 5번 호출하는 작업을 스레드로 진행하는 클래스를 생성
// 
// Main 에서 2개의 스레드를 만들어서 실행

// ex2) 생산자와 소비자 문제를 해결
// 생산자는 물건을 저장하고 소비자는 물건을 사용
// 생산자가 물건을 생산 해 주었을 때만 소비자는 물건을 사용
// 물건이 없을 때는 소비자는 대기해야 한다.
// 생산자는 물건을 생산할 때 소비자에게 알려 주어야 한다.
// 잔액을 가지고 잔액을 추가하는 메소드와 잔액을 감소시키는 메소드를 소유한 공유 자원 클래스
// 앞에서 만든 클래스의 save 메소드를 5번 호출하는 스레드 클래스
// 앞에서 만든 클래스의 decrease 메소드를 5번 호출하는 스레드 클래스
// 메인 클래스 - 스레드 클래스의 인스턴스를 만들어서 스레드 시작
// 잔액이 없는데도 불구하고 잔액을 감소시키는 메소드가 수행이 되어 잔액이 음수가 되는 현상이 발생한다.
// 잔액이 10000보다 작을 때는 잔액을 감소시키는 일을 못하게 해야 하고 잔액을 증가시켰으면 잔액을 감소시키는 일을 할 수 있도록 알려준다.

// **Java 에서 GUI 프로그램을 하는 방법
// 1. AWT
//    운영체제의 자원을 빌려서 사용
//    느리고 무겁기 때문에 잘 사용하지 않는다.
//    Swing 이나 Android 의 기반이 되기 때문에 주로 학습용으로만 사용

// 2. Swing
//    JVM 의 자원을 이용해서 사용
//    AWT 보다 가볍고 다양한 컴포넌트를 지원한다.
//    AWT 와 동일한 방식으로 프로그래밍

// 3. Java FX
//    가장 최근에 지원하기 시작한 GUI 프로그래밍
//    다양한 UI 를 제공
//    Swing 보다는 프로그래밍 하기 까다로운 편

// **AWT
// 1. Frame
//    하나의 윈도우에 해당하는 클래스
//    이 클래스의 인스턴스를 만들면 하나의 윈도우가 만들어진다.
//    기본적으로 좌표와 크기가 0,0이며 화면이 보이지 않도록 설정되어 있다.
//    크기와 화면 출력 설정을 반드시 해 주어야 한다.
//    Frame 을 상속받은 클래스를 만들고 이 클래스의 생성자에서 기본 설정을 한 후 Main 에서 인스턴스를 생성해 화면에 출력하는 형식

// 2. Panel
//    여러 개의 Component 들을 하나로 묶어주기 위해 사용하는 컨테이너
//    독자적으로 출력을 할 수 없기 때문에 Frame 이나 다른 Panel 의 위에 배치되어 화면에 출력된다.
//    컴포넌트 위에 배치할 때는 add(배치할 컴포넌트) 메소드를 이용한다.

// 3. Dialog(대화상자)
// 3-1. Model Dialog
//      대화상자가 출력되면 다른 컴포넌트에게 제어권을 옮길 수 없는 형식으로 코드 실행도 중단된다.
//      대화상자를 화면에서 제거해야만 다른 컴포넌트를 사용할 수 있고 코드도 수행된다.

// 3-2. Modeless Dialog 
//      대화상자가 출력된 상태에서도 다른 컴포넌트 에게 제어권을 옮길 수 있는 형식의 다이얼로그

// # 대화상자를 생성할 때는 생성자의 첫번째 매개변수에 자신의 부모 컴포넌트의 주소를 대입해야 한다.

// 4. Button
//    마우스로 클릭해서 작업을 수행하는 컴포넌트
//    

// 5. Checkbox
//    체크 박스와 라디오 버튼을 만들 수 있는 클래스
//    체크 박스는 하나도 선택하지 않을 수 잇고 여러 개를 선택 할 수도 있다.
//    라디오 버튼은 반드시 1개를 선택해야 할 때 사용한다.
//    라디오 버튼을 만들 때는 디폴트를 설정해 주어야 한다.
//    만들 때 생성자의 두 번째 매개변수로 CheckboxGroup 인스턴스를 대입하면 라디오 버튼이 된다.

// 6. Choice
//    ComboBox 라고 부르기도 한다.
//    여러 개의 항목 중 하나의 항목만 선택하도록 하고자 할 때 사용하는 Component 로 RadioButton 과 유사한 역할을 한다.

// 7. Label
//    텍스트를 출력하기 위한 Component

// 8. List
//    여러 개의 항목을 보여주고 그 중 하나 또는 여러 개를 선택 할 수 있도록 해주는 Component



package thread;

public class 필기 {

}
