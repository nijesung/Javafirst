// **테이블을 1개 만들어 전체 데이터를 조회하고
// 기본 키를 가지고 하나의 데이터를 조회할 수 있도록 하고
// 데이터를 삽입하는 작업을 MyBatis 를 이용해서 수행

// # https://dbeaver.io/ - 모든데이터베이스 무료임 ㅇ3ㅇ

// 1). 데이터베이스 작업
//     아이디: 문자열, 기본키
//     비밀번호: 문자열, 필수
//     이름: 문자열, 필수
//     폰번: 문자열, 필수

// 2). 샘플 데이터 입력

// 3.  데이터 작업 완료
//	   commit;

// 4). 샘플 데이터 확인

// 5). Simple Spring Maven 프로젝트 생성

// 6). Java 버전과 Spring 버전을 선택
//     spring 은 4.x 버전 권장
//     Java 는 1.6 버전 이상 권장

// 7). 사용할 라이브러리들의 의존성을 설정
//     pom.xml
// 7-1). 오라클을 사용하는 경우에는 repositories 를 설정해야 한다.
// 7-2). 데이터베이스(oracle, spring-jdbc, mybatis, mabatis-spring)
// 7-3). 테스트를 수행할 것이라면 spring-test 의존성의 scope 를 제거 

// ## 여기까지의 작업은 팀 프로젝트라면 한 명이 전부 작업하는 것이 일반적이다.

// 8). 데이터베이스 연도엥 사용할 Domain 클래스를 생성
//     Domain 클래스를 만들 때 변수명은 혼동을 가져오지 않기 위해
//     테이블의 컬럼 이름을 그대로 사용하는 경우가 많다.
//     com.pk.mybatis.domain.UfcVO
//     mybatis 까지는 공통되게 써 주어야 한다.

// 9). MyBatis 환경설정 파일을 생성
//     환경설정 파일에는 MyBatis 에 사용되는 Domain 클래스들의 경로를 줄여 쓰기 위한
//     패키지 이름을 등록하거나 매핑 정보를 설정한다.
//     MyBatis 에 관련된 파일들은 별도의 디렉토리를 만들어 저장한다. 
//     src/main/resources/mybatis/mybatis-config.xml

// 10). MyUser 테이블에 사용할 SQL 을 소유한 mapper 파일 작성
//      mapper 파일들은 한꺼번에 디렉토리 단위로 설정하는 경우가 많기 때문에
//      별도의 디렉토리를 만들어 작성한다.
//		src/main/resources/mybatis/mappers/ufc.xml

// 11). Spring Bean Configuration 파일을 생성해서 데이터베이스 접속 정보와
//      MyBatis 를 사용할 수 있는 Bean 을 생성하는 코드를 작성
//		src/main/resources/applicationContext.xml

// 12). 위의 설정 파일에 클래스의 인스턴스를 자동으로 만들어 주는 설정을 추가
// 12-1). context 네임스페이스 추가
// 12-2). context:component-scan base-package="자동으로 만들어 줄 상위 패키지이름"/> 을 추가

// 13). MyBatis 를 이용할 클래스를 생성
//      com.pk.mybatis.dao.UfcDao
// 13-1). 클래스의 bean 을 자동으로 생성하는 어노테이션(@Repository)을 클래스 선언 위에 추가
// 13-2). xml 파일에 작성한 sql 을 실행할 수 있는 SqlSession 타입의 변수를 인스턴스 변수로
//		  추가하고 자동으로 주입 받도록 설정

// 14). 전체 데이터를 가져오는 SQL 을 호출해서 출력
// 14-1). UfcDao 클래스에 메소드를 생성
// 14-2). Main 클래스를 생성하고 UfcDao 인스턴스를 찾아와서 메소드를 실행하고 출력

// 15). id 를 가지고 하나의 데이터를 가져오는 작업
// 15-1). UfcDao 클래스의 하나의 데이터를 가져오는 메소드를 생성
// 15-2). main 메소드에서 위의 메소드를 호출하고 결과 확인

// ## selectList 는 데이터가 없는 경우 null 이 아닌 size 가 0
//    selectOne 은 데이터가 없는 경우에 null 을 리턴한다.


// **프로시저 실행
// procedure
// 데이터베이스에서 자주 사용하는 구문을 하나의 함수 형태로 만들어 두고 호출하는 객체
// 프로시저를 만들어서 실행하면 프로시저는 메모리에 로드 된 상태에서 수행되기 때문에 속도가 빠르고
// 테이블 구조에 대한 정보가 누설될 위험도 없어 보안적인 측면으로도 우수하다.

// 1). 데이터베이스에 접속해서 데이터를 삽입하는 프로시저 만들기
// 2). 매퍼 파일에 위의 프로시저를 실행하는 SQL 구문을 작성
// 3). Dao 클래스에 데이터를 삽입하는 메소드를 생성
// 4). Ufc 테이블에 데이터를 삽입하는 메소드를 변경 해 준다.
// 5). main 메소드를 수정하고 실행

// **인터페이스 활용
// xml 을 이용하지 않고 인터페이스를 이용해서 MyBatis 를 활용할 수 있다.
// 인터페이스를 생성하고 메소드 위에 SQL	구문을 만들어서 사용한다.
// 장점은 별도의 xml 파일을 만들지 않기 때문에 구조를 간략화 할 수 있다.
// 단점은 자바코드로 만들기 때문에 sql 만 수정하는 경우에도 컴파일을 다시 해 실행시켜야 한다.

// 1). 환경설정 파일과 매퍼 파일 그리고 DAO 의 역할을 한꺼번에 수행하는 Mapper interface 를 생성한다.
// 2). com.pk.mybatis.dao.UfcInterface
// 3). applicationContext.xml 에서 MyBatis 연동 객체를 생성하는 bean 을 수정
// 4). main 메소드에서 테스트


// **Transaction
// 한 번에 이루어져야 하는 작업의 단위
// 하나의 작업이 하나의 트랜잭션이 될 수 있고 2개 이상의 작업이 하나의 트랜잭션이 될 수 있다.
// 하나의 트랜잭션에 전부 수행되거나 하나도 수행되지 않아야 한다.(All or Nothing)
// 관계형 데이터베이스에서 트랜잭션 관련 명령은 3가지
// commit(현재까지의 작업 내용을 원본에 반영), rollback(현재까지의 작업내용을 원본에 반영하지 않고 파기), 
// savepoint(rollback 할 수 있는 위치(지점) 생성)

// ## 관계형 데이터베이스는 기본적으로 DDL(create, alter, drop, truncate, rename),
// DCL(grant, revoke) 는 auto commit(명령어의 실행이 성공하면 자동으로 원본에 반영되는 것) 이다.
// select 는 트랜잭션과는 아무런 상관이 없는 별개의 명령어 이다.
// DML(insert, delete, update) 만이 트랜잭션의 명령의 영향을 받는다.
// NoSQL 은 트랜잭션이 존재하지 않으며 MySQL 에서도 테이블을 만들 때
// MyISAM 구조로 만들면 트랜잭션을 사용할 수 없다.
// 이 구조들은 읽기 전용일 가능성이 높다.

// ## 프로그래밍 언어마다 데이터베이스를 연동하는 방식이 다르듯이 트랜잭션을 적용하는 방법도 상이하다.
//    자바는 기본적으로 auto commit 이다.
//    자바에서 데이터베이스를 사용할 때는 일반적으로 manual commit 으로 변경한 후 작업이
//    성공적으로 수행되면 commit 을 하고 그렇지 않은 경우에는 rollback 을 하도록 한다.
//    트랜잭션을 설정하는 객체는 Dao 가 아니라 Service 이다.
//    한 명의 유저와 다른 한 명의 유저가 아이템을 거래하는 경우를 가정해 보자.
//    크게 보면 하나의 작업이기 때문에 Service 에서는 1개의 메소드로 처리한다.
//    이 때 실행되어야 하는 SQL 은 기본적으로 4개이거나 그 이상이다.
//    한 명의 유저에게는 아이템을 삭제시키고 소지금액을 증가시켜야 한다.
//    반대 편의 유저에게는 아이템을 추가시키고 소지금액을 감소시켜야 한다.
//    이 4개의 작업은 한 번에 이루어져야 한다.
//    Dao 에서는 4개의 메소드가 만들어져야 하므로 트랜잭션을 적용할 수 없고
//    Service 에서 해야 한다.


// **트랜잭션 적용
// oracle 의 dept 테이블과 연동되는 MyBatis 의 어노테이션을 이용하는 Mapper Interface
// 1. Simple Spring Maven 프로젝트 생성
// 2. Java Version 을 1.6 이상으로 변경
// 3. Spring Version 을 4.1.0 으로 설정
// 4. oracle, mybatis 를 사용하기 위한 라이브러리 설정
// 4-1. oracle 을 위한 repositories 를 설정
// 4-2. oracle 과 mybatis 를 사용하기 위한 dependencies 를 설정
// 5. VO 클래스 만들기
//    vo.Dept
// 6. 데이터베이스 작업을 위한 매퍼 인터페이스 만들기
//    dao.DeptMapper
// 7. Dao 를 가져와 사용할 Service 클래스를 만들고 Dao 를 주입받고 메소드를 호출하도록 설정
// 8. applicationContext.xml 생성
// 9. main 메소드를 소유한 Main 클래스를 만들고 Service 의 메소드 호출

// ## 하나의 메소드에서 동일한 데이터를 2번 삽입해서 무결성 위반 예외 발생
//    그렇지만 트랜잭션을 적용하지 않아서 첫 번째 데이터는 테이블에 삽입이 된다.

// 1. 트랜잭션을 적용하기 위해 applicationContext.xml 파일에 tx 네임스페이스 추가
// 2. 트랜잭션을 적용하고자 하는 메소드 위에 @Transactional 을 추가
//    Service 메소드 위에 추가
//    코드 수정 후 재실행

// ## 트랜잭션이 적용되어 예외가 발생하면 이전 작업도 취소가 된다.

package Web;

public class 필기0915 {

}
